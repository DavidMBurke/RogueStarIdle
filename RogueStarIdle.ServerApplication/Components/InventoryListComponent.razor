@using RogueStarIdle.ServerApplication.Shared.State;
@inject InventoryState inventoryState;

<div class="row" style="height:100%;">
    <div style="height: 100%; overflow-y: scroll; width:70%;">
        <table class="table" style="background-color: cornflowerblue;">
            <thead style="position:sticky; top: 0; background-color: cornflowerblue;">
                <tr style=" border-bottom: 2px black solid">
                    <th>Quantity</th>
                    <th>Name</th>
                    <th>Quality</th>
                </tr>
            </thead>
            <tbody style="max-height: 100%; overflow-y: auto;">
                @{
                    // group items by name. Items with different quality level or equipped status are treated as separate items for display purposes
                    var itemGroups = listItems.GroupBy(i => i.Name);
                }
                @foreach (var group in itemGroups)
                {
                    // if only one item in group, display info in one row. (multiple of same item with quantity >1 considered 1 item for this purpose)
                    if (group.Count() == 1)
                    {
                        Item item = group.First();
                        <tr style="width: 100%; height: 30px; @(item.Equipped ? "background-color: blue;" : string.Empty)" @onclick="() => SelectItem(item)">
                            <td>@item.Quantity</td>
                            <td>
                                @item.Name @if (item.Equipped)
                                {
                                    <text> <b> [Equipped]</b></text>
                                }
                            </td>
                            <td>@(item.QualityLevel > 0 ? $"{item.QualityLevel} / {item.MaxQualityLevel}" : "")</td>
                        </tr>
                    }
                    else
                    {
                        //display row with sum of all items of name, with dropdown to show individual quality levels and equipped status
                        <tr style="width: 100%; height: 30px; font: bold; @(group.Any(i => i.Equipped) && (!expandedViews.ContainsKey(group.Key) || (expandedViews.ContainsKey(group.Key) && !expandedViews[group.Key])) ? "background-color: blue;" : string.Empty)" @onclick="() => ToggleExpandedView(group.Key)">
                            <td>@group.Sum(i => i.Quantity)</td>
                            <td>@group.First().Name</td>
                            <td></td>
                        </tr>
                        if (expandedViews.ContainsKey(group.Key) && expandedViews[group.Key])
                        {
                            foreach (Item item in group)
                            {
                                <tr style="width: 100%; height: 30px; @(item.Equipped ? "background-color: blue;" : string.Empty)" @onclick="() => SelectItem(item)">
                                    <td>@item.Quantity</td>
                                    <td>
                                        @item.Name @if (item.Equipped)
                                        {
                                            <text> <b> [Equipped]</b></text>
                                        }
                                    </td>
                                    <td>@(item.QualityLevel > 0 ? $"{item.QualityLevel} / {item.MaxQualityLevel}" : "")</td>
                                </tr>
                            }
                        }
                    }
                }
            </tbody>
        </table>
    </div>
    <div style="width:30%; border: 3px solid black; height: 100%; background-color: cornflowerblue">
        @if (selectedItem != null)
        {
            <h4>
                @selectedItem.Name [@selectedItem.Quantity]
            </h4>
            <h5>Buy Price: @selectedItem.BuyPrice   Sell Price: @selectedItem.SellPrice</h5>
            @if (selectedItem.QualityLevel > 0)
            {
                <h5> Quality level: @selectedItem.QualityLevel / @selectedItem.MaxQualityLevel</h5>
            }
            @if (selectedItem.IsWeapon)
            {
                @getTypeMarkup(selectedItem);
                <h5>Base Damage: @selectedItem.MinBaseDamage - @selectedItem.MaxBaseDamage</h5>
                <h5>To-Hit Modifier: @selectedItem.ToHitModifier</h5>
                @getAllDamageTypeMarkups(selectedItem);
            }
            @if (selectedItem.IsArmor)
            {
                @getAllDefenseMarkups(selectedItem);
                @getAllDamageResistanceMarkups(selectedItem);
            }
            @foreach (var slot in selectedItem.EquipmentSlots)
            {
                <button @onclick="() => EquipItem(selectedItem, slot, equipmentState.MainCharacterEquipment)">
                    Equip @equipmentState.MainCharacterEquipment.getSlotNameById(slot)
                </button>
            }
        }
    </div>
</div>


@code {
    [Parameter] public string searchTerm { get; set; } = string.Empty;
    [Parameter] public EquipmentState equipmentState { get; set; } = new EquipmentState();
    private List<Item> listItems = new List<Item>(); // Items from inventory after search/sort
    public Item selectedItem = null; // Item stats are displayed for
    private Dictionary<string, bool> expandedViews = new Dictionary<string, bool>(); // Stores item groups expanded view status

    protected override async Task OnInitializedAsync()
    {
        inventoryState.OnChange += UpdateState;
        await base.OnInitializedAsync();
    }

    async Task UpdateState()
    {
        await OnParametersSetAsync();
        await InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        inventoryState.OnChange -= UpdateState;
    }

    // updates when parameters passed from parent are changes
    protected override async Task OnParametersSetAsync()
    {
        listItems = (await inventoryState.GetItemsByNameAsync(searchTerm)).ToList();
        listItems = listItems.Union(await inventoryState.GetItemsByTagAsync(searchTerm)).ToList();
        listItems.RemoveAll(i => i.Quantity < 1);
        listItems.Sort((x, y) => x.Equipped.CompareTo(y.Equipped));
        listItems.Sort((x, y) => y.QualityLevel.CompareTo(x.QualityLevel));
        listItems.Sort((x, y) => x.Name.CompareTo(y.Name));
    }

    // update expandedViews dictionary to expand / collapse groups
    private void ToggleExpandedView(string key)
    {
        if (expandedViews.ContainsKey(key))
        {
            expandedViews[key] = !expandedViews[key];
        }
        else
        {
            expandedViews[key] = true;
        }
    }

    private void SelectItem(Item item)
    {
        selectedItem = item;
    }

    public async void EquipItem(Item item, int slotId, EquipmentSet equipmentSet)
    {
        if (item.Equipped)
        {
            return;
        }
        foreach (var property in typeof(EquipmentSet).GetProperties())
        {
            if (property.PropertyType != typeof(EquipmentSlot))
            {
                continue; // skip if not equipment slot
            }
            EquipmentSlot slot = (EquipmentSlot)property.GetValue(equipmentSet);
            if (slot.Id != slotId)
            {
                continue; // skip if not correct slot
            }
            // replace unequipped item with equipped item
            Item itemToEquip = item.createCopy();
            itemToEquip.Equipped = true;
            inventoryState.removeFromInventory(item);
            inventoryState.addToInventory(itemToEquip);
            if (slot.Item != null)
            {
                // replace previously equipped item with unequipped item
                Item unequippedItem = slot.Item.createCopy();
                inventoryState.removeFromInventory(unequippedItem);
                unequippedItem.Equipped = false;
                inventoryState.addToInventory(unequippedItem);
            }
            if (!itemToEquip.StacksInEquipmentSlot)
            {
                itemToEquip.Quantity = 1;
            }
            slot.Item = itemToEquip; //equip item
            break;
        }
        await OnParametersSetAsync();
    }

    // Return MarkupString of weapon type for display
    public MarkupString getTypeMarkup(Item item)
    {
        if (item.IsMelee)
            return new MarkupString("<h5>Type: Melee<h5/>");
        if (item.IsRanged)
            return new MarkupString("<h5>Type: Ranged<h5/>");
        if (item.IsExplosive)
            return new MarkupString("<h5>Type: Explosive<h5/>");
        return new MarkupString("");
    }

    // Return all active damage ranges in one MarkupString for display
    public MarkupString getAllDamageTypeMarkups(Item item)
    {
        string markup = "";
        markup += getDamageMarkupByType("Slashing", selectedItem.PercentSlashingDamage, selectedItem);
        markup += getDamageMarkupByType("Piercing", selectedItem.PercentPiercingDamage, selectedItem);
        markup += getDamageMarkupByType("Crushing", selectedItem.PercentCrushingDamage, selectedItem);
        markup += getDamageMarkupByType("Acid", selectedItem.PercentAcidDamage, selectedItem);
        markup += getDamageMarkupByType("Poison", selectedItem.PercentPoisonDamage, selectedItem);
        markup += getDamageMarkupByType("Fire", selectedItem.PercentFireDamage, selectedItem);
        markup += getDamageMarkupByType("Shock", selectedItem.PercentShockDamage, selectedItem);
        return new MarkupString(markup);
    }

    // Return MarkupString of damage range of given type
    public MarkupString getDamageMarkupByType(string type, int percent, Item item)
    {
        if (percent < 1)
        {
            return new MarkupString("");
        }
        int min = (item.MinBaseDamage * percent) / 100;
        int max = (item.MaxBaseDamage * percent) / 100;
        string markup = $"<h5>{type} Damage: {min} - {max}</h5>";
        return new MarkupString(markup);
    }

    // Return all active Defenses in one MarkupString for display
    public MarkupString getAllDefenseMarkups(Item item)
    {
        string markup = "";
        markup += getDefenseMarkupByType("Melee", item.MeleeDefense, item);
        markup += getDefenseMarkupByType("Ranged", item.RangedDefense, item);
        markup += getDefenseMarkupByType("Explosive", item.ExplosiveDefense, item);
        markup += getDefenseMarkupByType("Kinetic", item.KineticDefense, item);
        markup += getDefenseMarkupByType("Energy", item.EnergyDefense, item);
        markup += getDefenseMarkupByType("Psychic", item.PsychicDefense, item);
        return new MarkupString(markup);
    }

    // Return MarkupString of individual type Defense
    public MarkupString getDefenseMarkupByType(string type, int defense, Item item)
    {
        if (defense < 1)
        {
            return new MarkupString("");
        }
        string markup = $"<h5>{type} Defense: {defense}</h5>";
        return new MarkupString(markup);
    }

    // Return all active DRs in one MarkupString for desplay
    public MarkupString getAllDamageResistanceMarkups(Item item)
    {
        string markup = "";
        markup += getDamageResistanceMarkupByType("Kinetic", item.KineticDamageReduction, item);
        markup += getDamageResistanceMarkupByType("Psychic", item.PsychicDamageReduction, item);
        markup += getDamageResistanceMarkupByType("Energy", item.EnergyDamageReduction, item);
        markup += getDamageResistanceMarkupByType("Piercing", item.KineticDamageReduction, item.PiercingDamageReduction, item);
        markup += getDamageResistanceMarkupByType("Crushing", item.KineticDamageReduction, item.CrushingDamageReduction, item);
        markup += getDamageResistanceMarkupByType("Slashing", item.KineticDamageReduction, item.SlashingDamageReduction, item);
        markup += getDamageResistanceMarkupByType("Fire", item.EnergyDamageReduction, item.FireDamageReduction, item);
        markup += getDamageResistanceMarkupByType("Acid", item.EnergyDamageReduction, item.AcidDamageReduction, item);
        markup += getDamageResistanceMarkupByType("Poison", item.EnergyDamageReduction, item.PoisonDamageReduction, item);
        markup += getDamageResistanceMarkupByType("Shock", item.EnergyDamageReduction, item.ShockDamageReduction, item);
        return new MarkupString(markup);
    }

    // Return damage resistance MarkupString
    public MarkupString getDamageResistanceMarkupByType(string type, int dr, Item item)
    {
        if (dr < 1)
        {
            return new MarkupString("");
        }
        string markup = $"<h5>{type} Resistance: {dr}</h5>";
        return new MarkupString(markup);
    }

    // Return damage resistance MarkupString if greater than DR of category.
    // Category DR applies to all damage types, (i.e. Energy applies to Fire, Acid, Shock and Poison, while Kinetic applies to Piercing, Slashing and Crushing)
    public MarkupString getDamageResistanceMarkupByType(string type, int categoryDR, int typeDR, Item item)
    {
        if (typeDR <= categoryDR)
        {
            return new MarkupString("");
        }
        string markup = $"<h5>{type} Resistance: {typeDR}</h5>";
        return new MarkupString(markup);
    }
}
