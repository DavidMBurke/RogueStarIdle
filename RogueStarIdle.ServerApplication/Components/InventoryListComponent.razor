@using RogueStarIdle.ServerApplication.Shared.State;
@inject InventoryState inventoryState;

<div class="row" style="height:100%;">
    <div style="height: 100%; overflow-y: scroll; width:70%;">
        <table class="table" style="background-color: cornflowerblue;">
            <thead style="position:sticky; top: 0; background-color: cornflowerblue;">
                <tr style=" border-bottom: 2px black solid">
                    <th>Quantity</th>
                    <th>Name</th>
                    <th>Quality</th>
                </tr>
            </thead>
            <tbody style="max-height: 100%; overflow-y: auto;">
                @{
                    var itemGroups = listItems.GroupBy(i => i.Name);
                } 
                @foreach (var group in itemGroups) 
                {
                    if (group.Count() == 1)
                    {
                        Item item = group.First();
                        <tr style="width: 100%; height: 30px; @(item.Equipped ? "background-color: blue;" : string.Empty)" @onclick="() => SelectItem(item)">
                            <td>@item.Quantity</td>
                            <td>@item.Name @if (item.Equipped) {<text> <b> [Equipped]</b></text>}</td>
                            <td>@item.QualityLevel / @item.MaxQualityLevel</td>
                        </tr>
                    } else {
                        <tr style="width: 100%; height: 30px; font: bold; @(group.Any(i => i.Equipped) && (!expandedViews.ContainsKey(group.Key) || (expandedViews.ContainsKey(group.Key) && !expandedViews[group.Key])) ? "background-color: blue;" : string.Empty)" @onclick="() => ToggleExpandedView(group.Key)">
                            <td>@group.Sum(i => i.Quantity)</td>
                            <td>@group.First().Name</td>
                            <td></td>
                        </tr>
                        if (expandedViews.ContainsKey(group.Key) && expandedViews[group.Key])
                        {
                            foreach (Item item in group)
                            {
                                <tr style="width: 100%; height: 30px; @(item.Equipped ? "background-color: blue;" : string.Empty)"
                    @onclick="() => SelectItem(item)">
                                <td>@item.Quantity</td>
                                    <td>@item.Name @if (item.Equipped) {<text> <b> [Equipped]</b></text>}</td>
                                    <td>@item.QualityLevel / @item.MaxQualityLevel</td>
                            </tr>
                            }
                        }
                    }
                }
            </tbody>
        </table>
    </div>
    <div style="width:30%; border: 3px solid black; height: 100%; background-color: cornflowerblue">
        @if (selectedItem != null)
        {   
            <h4>
                @selectedItem.Name [@selectedItem.Quantity]
            </h4>
            <h5>Buy Price: @selectedItem.BuyPrice   Sell Price: @selectedItem.SellPrice</h5>
            @if (selectedItem.IsWeapon || selectedItem.IsArmor)
            {
                <h5> Quality level: @selectedItem.QualityLevel / @selectedItem.MaxQualityLevel</h5>
            }
            @if (selectedItem.IsWeapon)
            {
                @checkType(selectedItem);
                <h5>Base Damage: @selectedItem.MinBaseDamage - @selectedItem.MaxBaseDamage</h5>
                <h5>To-Hit Modifier: @selectedItem.ToHitModifier</h5>
                @checkAllDamageTypes(selectedItem);
            }
            @if (selectedItem.IsArmor)
            {
                @checkAllDefenseTypes(selectedItem);
                @checkAllDamageResistances(selectedItem);
            }
            @foreach(var slot in selectedItem.EquipmentSlots)
            {
                <button @onclick="() => EquipItem(selectedItem, slot, equipmentState.MainCharacterEquipment)">
                    Equip @getSlotName(selectedItem, slot, equipmentState.MainCharacterEquipment)
                </button>
            }
        }
    </div>
</div>


@code {
    private List<Item> listItems = new List<Item>();

    private bool reload = false;

    [Parameter]
    public string searchTerm { get; set; } = string.Empty;

    [Parameter]
    public EquipmentState equipmentState { get; set; } = new EquipmentState();

    public Item selectedItem = null;

    private Dictionary<string, bool> expandedViews = new Dictionary<string, bool>();

    private void ToggleExpandedView(string key)
    {
        if (expandedViews.ContainsKey(key))
        {
            expandedViews[key] = !expandedViews[key];
        }
        else
        {
            expandedViews[key] = true;
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        listItems = (await inventoryState.GetItemsByNameAsync(searchTerm)).ToList();
        listItems = listItems.Union(await inventoryState.GetItemsByTagAsync(searchTerm)).ToList();
        listItems.RemoveAll(i => i.Quantity < 1);
        listItems.Sort((x,y) => x.Equipped.CompareTo(y.Equipped));
        listItems.Sort((x, y) => y.QualityLevel.CompareTo(x.QualityLevel));
        listItems.Sort((x, y) => x.Name.CompareTo(y.Name));
    }

    private void SelectItem(Item item)
    {
        selectedItem = item;
    }

    public async void EquipItem(Item item, int id, EquipmentSet equipmentSet)
    {
        foreach (var property in typeof(EquipmentSet).GetProperties())
        {
            if (property.PropertyType == typeof(EquipmentSlot))
            {
                EquipmentSlot slot = (EquipmentSlot)property.GetValue(equipmentSet);
                if (slot.Id == id)
                {

                    if (slot.Item != null)
                    {
                        Item unequippedItem = slot.Item.createCopy();
                        unequippedItem.Equipped = false;
                        inventoryState.inventory.Add(unequippedItem);
                        inventoryState.inventory.Remove(slot.Item);
                    }

                    item.Quantity -= 1;
                    Item equippedItem = item.createCopy();
                    equippedItem.Quantity = 1;
                    equippedItem.Equipped = true;
                    SelectItem(equippedItem);
                    inventoryState.inventory.Add(equippedItem);
                    slot.Item = equippedItem;
                    if (item.Quantity == 0)
                    {                        
                        inventoryState.inventory.Remove(item);
                    }
                    break;
                }
            }
        }
        await OnParametersSetAsync();
    }

    public string getSlotName(Item item, int id, EquipmentSet equipmentSet)
    {
        foreach (var property in typeof(EquipmentSet).GetProperties())
        {
            if (property.PropertyType == typeof(EquipmentSlot))
            {
                EquipmentSlot slot = (EquipmentSlot)property.GetValue(equipmentSet);
                if (slot.Id == id)
                {
                    return property.Name;
                }
            }
        }
        return "Error";
    }

    // Return MarkupString of weapon type for display
    public MarkupString checkType( Item item)
    {
        if (item.IsMelee)
        {
            return new MarkupString("<h5>Type: Melee<h5/>");
        }
        if (item.IsRanged)
        {
            return new MarkupString("<h5>Type: Ranged<h5/>");
        }
        if (item.IsExplosive)
        {
            return new MarkupString("<h5>Type: Explosive<h5/>");
        }
        return new MarkupString("");
    }

    // Return all active damage ranges in one MarkupString for display
    public MarkupString checkAllDamageTypes(Item item)
    {
        string markup = "";
        markup += @checkDamage("Slashing", selectedItem.PercentSlashingDamage, selectedItem);
        markup += @checkDamage("Piercing", selectedItem.PercentPiercingDamage, selectedItem);
        markup += @checkDamage("Crushing", selectedItem.PercentCrushingDamage, selectedItem);
        markup += @checkDamage("Acid", selectedItem.PercentAcidDamage, selectedItem);
        markup += @checkDamage("Poison", selectedItem.PercentPoisonDamage, selectedItem);
        markup += @checkDamage("Fire", selectedItem.PercentFireDamage, selectedItem);
        markup += @checkDamage("Shock", selectedItem.PercentShockDamage, selectedItem);
        return new MarkupString(markup);
    }

    // Return MarkupString of damage range of given type
    public MarkupString checkDamage(string type, int percent, Item item)
    {
        if (percent < 1)
        {
            return new MarkupString("");
        }
        int min = (item.MinBaseDamage * percent) / 100;
        int max = (item.MaxBaseDamage * percent) / 100;
        string markup = $"<h5>{type} Damage: {min} - {max}</h5>";
        return new MarkupString(markup);
    }

    // Return all active Defenses in one MarkupString for display
    public MarkupString checkAllDefenseTypes(Item item)
    {
        string markup = "";
        markup += checkDefense("Melee", item.MeleeDefense, item);
        markup += checkDefense("Ranged", item.RangedDefense, item);
        markup += checkDefense("Explosive", item.ExplosiveDefense, item);
        markup += checkDefense("Kinetic", item.KineticDefense, item);
        markup += checkDefense("Energy", item.EnergyDefense, item);
        markup += checkDefense("Psychic", item.PsychicDefense, item);
        return new MarkupString(markup);
    }

    // Return MarkupString of individual type Defense
    public MarkupString checkDefense(string type, int defense, Item item)
    {
        if (defense < 1)
        {
            return new MarkupString("");
        }
        string markup = $"<h5>{type} Defense: {defense}</h5>";
        return new MarkupString(markup);
    }

    // Return all active DRs in one MarkupString for desplay
    public MarkupString checkAllDamageResistances(Item item)
    {
        string markup = "";
        markup += checkDamageResistance("Kinetic", item.KineticDamageReduction, item);
        markup += checkDamageResistance("Psychic", item.PsychicDamageReduction, item);
        markup += checkDamageResistance("Energy", item.EnergyDamageReduction, item);
        markup += checkDamageResistance("Piercing", item.KineticDamageReduction, item.PiercingDamageReduction, item);
        markup += checkDamageResistance("Crushing", item.KineticDamageReduction, item.CrushingDamageReduction, item);
        markup += checkDamageResistance("Slashing", item.KineticDamageReduction, item.SlashingDamageReduction, item);
        markup += checkDamageResistance("Fire", item.EnergyDamageReduction, item.FireDamageReduction, item); 
        markup += checkDamageResistance("Acid", item.EnergyDamageReduction, item.AcidDamageReduction, item);
        markup += checkDamageResistance("Poison", item.EnergyDamageReduction, item.PoisonDamageReduction, item);
        markup += checkDamageResistance("Shock", item.EnergyDamageReduction, item.ShockDamageReduction, item);
        return new MarkupString(markup);
    }

    // Return damage resistance MarkupString
    public MarkupString checkDamageResistance(string type, int dr, Item item)
    {
        if (dr < 1)
        {
            return new MarkupString("");
        }
        string markup = $"<h5>{type} Resistance: {dr}</h5>";
        return new MarkupString(markup);
    }

    // Return damage resistance MarkupString if greater than DR of category. 
    // Category DR applies to all damage types, (i.e. Energy applies to Fire, Acid, Shock and Poison, while Kinetic applies to Piercing, Slashing and Crushing)
    public MarkupString checkDamageResistance(string type, int categoryDR, int typeDR, Item item)
    {
        if (typeDR <= categoryDR)
        {
            return new MarkupString("");
        }
        string markup = $"<h5>{type} Resistance: {typeDR}</h5>";
        return new MarkupString(markup);
    }
}
