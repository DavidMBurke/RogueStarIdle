@page "/settings"
@using RogueStarIdle.ServerApplication.Shared.State;
@inject ActionState actionState;
@inject CharacterState characterState;
@inject InventoryState inventoryState;
@inject TimeState timeState;
@inject IJSRuntime JSRuntime
@using System.Text.Json;
@using System.Reflection;
@using System.Security.Cryptography;
@using System.Text;
@using System.IO.Compression;

<div class="page-content-container">
    <div class="column">
        <div style="row">
            <button @onclick="() => Save(actionState, characterState, inventoryState, timeState)">Save</button>
            <button @onclick="() => Load()">Load</button>
            <button @onclick="() => ClearSave()">Clear Save</button>
        </div>
        <input @bind-value="importExport"/>
        <div style="row">
            <button @onclick="() => Export(actionState, characterState, inventoryState, timeState)">Export</button>
            <button @onclick="() => Import()">Import</button>
        </div>
    </div>
</div>

@code {
    private string key = "Rogue Star Baybeeeee";
    private string importExport = "";

    private async void Save(ActionState actionState, CharacterState characterState, InventoryState inventoryState, TimeState timeState)
    {
        SaveState saveState = new SaveState(actionState, characterState, inventoryState, timeState);
        string save = Serialize(saveState);
        byte[] encryptedSave = await EncryptAsync(save, key);
        string finalSave = Serialize(encryptedSave);
        SaveToLocalstorage("saveState", finalSave);
    }

    private async void Export(ActionState actionState, CharacterState characterState, InventoryState inventoryState, TimeState timeState)
    {
        SaveState saveState = new SaveState(actionState, characterState, inventoryState, timeState);
        string save = Serialize(saveState);
        byte[] encryptedSave = await EncryptAsync(save, key);
        importExport = Serialize(encryptedSave);
    }

    private async void Load()
    {
        string encryptedLoadString = await LoadFromLocalstorage("saveState");
        byte[] encryptedLoadBytes = Deserialize<byte[]>(encryptedLoadString);
        string decryptedLoad = await DecryptAsync(encryptedLoadBytes, key);
        SaveState loadedState = Deserialize<SaveState>(decryptedLoad);
        if (loadedState == default(SaveState))
        {
            return;
        }
        StateCopy(actionState, loadedState.ActionState);
        StateCopy(characterState, loadedState.CharacterState);
        StateCopy(inventoryState, loadedState.InventoryState);
        StateCopy(timeState, loadedState.TimeState);
    }

    private async void Import()
    {
        byte[] encryptedLoadBytes = Deserialize<byte[]>(importExport);
        string decryptedLoad = await DecryptAsync(encryptedLoadBytes, key);
        SaveState loadedState = Deserialize<SaveState>(decryptedLoad);
        if (loadedState == default(SaveState))
        {
            return;
        }
        StateCopy(actionState, loadedState.ActionState);
        StateCopy(characterState, loadedState.CharacterState);
        StateCopy(inventoryState, loadedState.InventoryState);
        StateCopy(timeState, loadedState.TimeState);
    }

    private async void ClearSave()
    {
        DeleteFromLocalstorage("saveState");
    }

    private async Task SaveToLocalstorage(string key, string value)
    {
        await JSRuntime.InvokeVoidAsync("localStorage.setItem", key, value);
    }

    private async Task<string> LoadFromLocalstorage(string key)
    {
        return await JSRuntime.InvokeAsync<string>("localStorage.getItem", key);
    }

    private async Task DeleteFromLocalstorage(string key)
    {
        await JSRuntime.InvokeVoidAsync("localStorage.removeItem", key);
    }

    private string Serialize<T>(T state)
    {
        JsonSerializerOptions options = new JsonSerializerOptions { IncludeFields = true };
        string save = JsonSerializer.Serialize(state, options);
        return save;
    }

    private static T Deserialize<T>(string? json)
    {
        if (json == null || json == "")
        {
            return default(T);
        }
        JsonSerializerOptions options = new JsonSerializerOptions { IncludeFields = true };
        T? state = JsonSerializer.Deserialize<T>(json, options);
        return state;
    }

    private void StateCopy<T>(T state, T loadedState)
    {
        foreach (PropertyInfo property in typeof(T).GetProperties())
        {
            if (!property.CanRead || !property.CanWrite)
            {
                continue;
            }
            object value = property.GetValue(loadedState);
            property.SetValue(state, value);
        }
    }

    /// <summary>
    /// Encryption copypasta'd from https://code-maze.com/csharp-string-encryption-decryption/
    /// </summary>

    private byte[] IV =
    {
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    0x09, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16
    };

    public async Task<byte[]> EncryptAsync(string clearText, string passphrase)
    {
        using Aes aes = Aes.Create();
        aes.Key = DeriveKeyFromPassword(passphrase);
        aes.IV = IV;
        using MemoryStream output = new();
        using CryptoStream cryptoStream = new(output, aes.CreateEncryptor(), CryptoStreamMode.Write);
        using (DeflateStream compressionStream = new(cryptoStream, CompressionMode.Compress))
        {
            await compressionStream.WriteAsync(Encoding.UTF8.GetBytes(clearText));
        }
        return output.ToArray();
    }

    public async Task<string> DecryptAsync(byte[] encrypted, string passphrase)
    {
        using Aes aes = Aes.Create();
        aes.Key = DeriveKeyFromPassword(passphrase);
        aes.IV = IV;
        using MemoryStream input = new(encrypted);
        using CryptoStream cryptoStream = new(input, aes.CreateDecryptor(), CryptoStreamMode.Read);
        using (DeflateStream decompressionStream = new(cryptoStream, CompressionMode.Decompress))
        {
            using MemoryStream output = new();
            await decompressionStream.CopyToAsync(output);
            return Encoding.UTF8.GetString(output.ToArray());
        }
    }

    private byte[] DeriveKeyFromPassword(string password)
    {
        var emptySalt = Array.Empty<byte>();
        var iterations = 1000;
        var desiredKeyLength = 16; // 16 bytes equal 128 bits.
        var hashMethod = HashAlgorithmName.SHA384;
        return Rfc2898DeriveBytes.Pbkdf2(Encoding.Unicode.GetBytes(password),
                                         emptySalt,
                                         iterations,
                                         hashMethod,
                                         desiredKeyLength);
    }
}